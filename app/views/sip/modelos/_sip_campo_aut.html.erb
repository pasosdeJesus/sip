
<% if @registro.nil? %>
  @registro no puede ser nil. Debe ser objeto que se edita.
  <% return %>
<% end %>
<% if atr.nil? %>
  atr no puede ser nil. Debe ser atributo por editar.
  <% return %>
<% end %>
<% if f.nil? %>
  f no puede ser nil. Debe ser formulario.
  <% return %>
<% end %>
<% atexternos = {} %>
<% if defined?(htmlexterno) %>
  <% atexternos.merge!(htmlexterno) %>
<% end %>
<% if defined?(atributos_externos) %>
  <% atexternos.merge!(atributos_externos) %>
<% end %>
<% atinternos = {} %>
<% if defined?(atributos_internos) %>
  <% atinternos = atributos_internos %>
<% end %>




<% alf = @registro.class.asociacion_llave_foranea(atr) %>
<% vatr = atr.to_s.gsub(/[^a-z_A-Z0-9]/, '') %>
<% rtavatr = clase.pluralize.underscore + "/campo_#{vatr}" %>
<% (ri, rm, rd)=clase.pluralize.underscore.rpartition("/") %>
<% regatr = atr.class == Hash ? @registro.send(atr.keys.first) : @registro.send(atr) %>
<% valorp = Sip::ModeloHelper.poromision_sf(
  params, atr, regatr) %>
<% #byebug %>
<% if alf # Es llave Foranea   %>
  <% n = alf.name %>
  <% nclase = alf.class_name.constantize %>
  <% col = Sip::ModeloHelper.opciones_tabla_basica(nclase, f, n) %>
  <% desh= false %>
  <% nosel = {} %>
  <% #puts "OJO atr=#{atr}, valorp=#{valorp}" %>
  <% if defined?(opciones) && opciones.keys &&
      opciones.keys.include?(:deshabilitar) && opciones[:deshabilitar] %>
    <% desh = true %>
    <% nosel = { 
      onfocus: "this.defaultIndex=this.selectedIndex;",
      onchange: "this.selectedIndex=this.defaultIndex;"
    } %>
    <% # Solución de https://github.com/heartcombo/simple_form/issues/1513 %>
  <% end %>
  <% if !defined?(opciones) || !opciones.keys.include?(:chosen) || opciones[:chosen] %>
    <% atinternos.merge!({ class: desh ? '' : 'chosen-select' }) %>
  <% end %>
  <% atinternos.merge!(nosel) %>
  <% opassoc = {
    collection: col.order(nclase.send(:orden_presenta_nombre)),
    label_method: :presenta_nombre,
    value_method: :id,
    disabled: desh,
    include_blank: true,
    input_html: atinternos,
    wrapper_html: atexternos,
  } %>
  <% if @registro.respond_to?(n) && @registro.send(n) &&
    @registro.send(n).id %>
    <% opassoc[:selected] = @registro.send(n).id %>
  <% else %>
    <!-% valorp = Sip::ModeloHelper.poromision_sf(params, atr) %-->
    <% opassoc[:selected] = valorp %>
  <% end %>
  <%= f.association n, opassoc %>
<% elsif @registro.class.asociacion_combinada(atr) %>
  <% #byebug %>
  <% r = @registro.class.asociacion_combinada(atr) # Tabla Combinada  %>
  <% if lookup_context.find_all(r.name.to_s + '_campos', [], true).any? %>
    <% # Suponemos que tiene un accepts_nested_attributes_for %>
    <% nd = r.class_name.constantize.human_attribute_name(r.name.to_s) %>
    <div class="panel panel-default">
      <div class="panel-heading"><%= nd %></div>
      <div class="panel-body">
        <%= f.simple_fields_for r.name.to_sym do |cfo| %>
          <%= render (r.name.to_s + '_campos'), :f => cfo %>
        <% end %>
        <div class="links">
          <%= link_to_add_association "Añadir #{nd}", f, 
            r.name.to_sym, partial: (r.name.to_s + '_campos'),
            :class => 'btn btn-sm btn-primary' %>
        </div>
      </div> <!-- .panel-body -->
    </div> <!-- .panel -->
  <% else %>
    <% # r.class.to_s == 
      #'ActiveRecord::Reflection::ThroughReflection' # Tabla combinada %>
    <% n = r.name %>
    <% nclase = r.class_name.constantize %>
    <% col = Sip::ModeloHelper.opciones_tabla_basica(nclase, f, n) %>
    <% atinternos.merge!({ class: 'chosen-select' }) %>
    <%= f.association n,
      collection: col.order(nclase.send(:orden_presenta_nombre)),
      label_method: lambda {|e| e.presenta_nombre }, #:nombre,
      value_method: :id ,
      include_blank: true,
      input_html: atinternos,
      wrapper_html: atexternos
    %>
  <% end %>
<% elsif @registro.class && (
  @registro.class.columns_hash[atr.to_s] || 
  @registro.class.columns_hash[atr] ) %>
  <% # Escogemos el control %>
  <% #byebug %>
  <% col = @registro.class.columns_hash[atr.to_s] || 
  @registro.class.columns_hash[atr.to]  %>
  <% if col && col.type == :date then %>
    <% # fecha %> 
    <% atinternos.merge!({ type: 'date' }) %>
    <%= f.input atr.to_sym, 
      as: :string,
      input_html: atinternos,
      wrapper_html: atexternos %>
  <% elsif col && col.type == :integer %>
    <% if defined?(opciones) && opciones.keys && 
        opciones.keys.include?(:etiqueta) && opciones[:etiqueta] == false %>
      <%= f.input atr.to_sym, 
        as: :integer,
        label: false, 
        input_html: atinternos,
        wrapper_html: atexternos %>
    <% else %>
      <% atinternos.merge!({ value: valorp }) %>
      <%= f.input atr.to_sym, as: :integer,
        input_html: atinternos, 
        wrapper_html: atexternos %>
    <% end %>
  <% elsif col.limit && col.limit > 1000 %>
    <% atinternos.merge!({ value: valorp }) %>
    <%= f.input atr.to_sym, 
      as: :text,
      input_html: atinternos,
      wrapper_html: atexternos %>
  <% else %>
    <% atinternos.merge!({ value: valorp }) %>
    <%= f.input atr.to_sym,
      input_html: atinternos,
      wrapper_html: atexternos %>
  <% end %>
<% else %>
    <% if (atr.class == String || atr.class == Symbol) && 
        (atr.to_s[0, 5] == 'fecha' || atr.to_s[-11..-1] == '_localizada')  %>
      <% atinternos.merge!({ "data-behaviour" => "datepicker"}) %>
      <%= f.input atr.to_sym,
        as:  :string,
        autocomplete: "off",
        input_html:  atinternos,
        wrapper_html: atexternos %>
    <% elsif @registro.respond_to?(atr) then %>
      <% atinternos.merge!({ value: valorp }) %>
      <%= f.input atr.to_sym,
        input_html: atinternos,
        wrapper_html: atexternos %>
    <% else %>
      <%= "Campo #{atr} sin control para editar"  %>
    <% end %>
<% end %>
